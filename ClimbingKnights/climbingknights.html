<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Climbing Knights</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Noto+Sans+KR:wght@400;700&display=swap');
        :root { 
            --primary: #FFD700; 
            --danger: #FF4444; 
            --ui-bg: rgba(0, 0, 0, 0.9); 
        }
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Noto Sans KR', sans-serif; 
            color: white; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            touch-action: none; 
        }
        #game-container { 
            position: relative; 
            width: 100%; 
            max-width: 480px; 
            height: 100%; 
            background: #222; 
            overflow: hidden; 
        }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        .ui-layer { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            background: var(--ui-bg); 
            z-index: 10; 
        }
        .hidden { 
            display: none !important; 
        }
        .box { 
            background: #333; 
            padding: 30px; 
            border-radius: 15px; 
            border: 2px solid var(--primary); 
            text-align: center; 
            width: 80%; 
            max-width: 400px;
        }
        input { 
            width: 100%; 
            padding: 12px; 
            margin: 10px 0; 
            border-radius: 5px; 
            border: none; 
            font-size: 16px; 
            box-sizing: border-box; 
        }
        button { 
            width: 100%; 
            padding: 15px; 
            margin-top: 15px; 
            border: none; 
            border-radius: 5px; 
            background: var(--primary); 
            color: black; 
            font-weight: bold; 
            cursor: pointer; 
            font-size: 18px; 
        }
        button:active {
            opacity: 0.8;
        }
        #hud { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 5; 
            font-family: 'Black Ops One', cursive; 
            font-size: 24px; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); 
            pointer-events: none; 
        }
        #zone-txt {
            font-size: 14px;
            color: var(--primary);
            margin-top: 5px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="hud" class="hidden">
        <div id="dist-txt">0m</div>
        <div id="zone-txt">BASIC ZONE</div>
    </div>

    <div id="login-screen" class="ui-layer">
        <h1 style="font-family: 'Black Ops One'; color: var(--primary); font-size: 40px; margin-bottom: 5px;">CLIMBING KNIGHTS</h1>
        <p style="margin-bottom: 20px; color: #aaa;">마왕성 탑을 올라라</p>
        <div class="box">
            <input type="text" id="username" placeholder="유저명">
            <input type="password" id="password" placeholder="비밀번호">
            <button onclick="game.login()">Login</button>
        </div>
    </div>

    <div id="main-menu" class="ui-layer hidden">
        <h2 id="welcome-msg" style="color: var(--primary);">님, 안녕하세요!</h2>
        <p>최고 기록: <span id="best-dist">0</span>m</p>
        <button style="width: 220px;" onclick="game.start()">스토리 모드 시작</button>
        <button style="width: 220px; background: #555; color: white;" onclick="game.logout()">로그아웃</button>
    </div>

    <div id="game-over" class="ui-layer hidden">
        <h1 id="over-title" style="color: var(--danger); font-size: 40px;">원정 실패</h1>
        <p id="over-stats"></p>
        <button style="width: 200px;" onclick="game.start()">재도전</button>
        <button style="width: 200px; background: #555; color: white;" onclick="game.showMenu()">메뉴로</button>
    </div>

    <canvas id="gameCanvas"></canvas>
</div>

<script>
/**
 * Climbing Knights - Complete Implementation
 * 기획서 기반 전체 구현
 */

const CONFIG = {
    WIDTH: 480, 
    HEIGHT: 854,
    GRAVITY: 0.35, 
    JUMP_SPEED: 16,
    ARROW_ANGLE_RANGE: 60, // ±60도 = 120도 범위
    HOLD_GRAB_DISTANCE: 55,
    HOLD_SPAWN_DISTANCE: 180,
};

// 구간 정의
const ZONES = [
    { name: 'BASIC', start: 0, end: 2000, bgIndex: 0 },
    { name: 'ROCK', start: 2000, end: 4000, bgIndex: 1 },
    { name: 'SNOW', start: 4000, end: 6000, bgIndex: 2 },
    { name: 'LAVA', start: 6000, end: 8000, bgIndex: 3 },
    { name: 'CASTLE', start: 8000, end: 10000, bgIndex: 4 }
];

class ImageLoader {
    constructor() {
        this.images = {};
        this.loaded = 0;
        this.total = 0;
        this.basePath = 'assets/';
    }

    load(key, path) {
        this.total++;
        const img = new Image();
        img.onload = () => {
            this.loaded++;
            this.images[key] = img;
        };
        img.onerror = () => {
            console.warn(`Failed to load: ${path}`);
            this.loaded++;
        };
        img.src = this.basePath + path;
        return img;
    }

    loadAll() {
        // 배경
        for(let i = 0; i <= 5; i++) {
            this.load(`bg_${i}`, `background/background_${i}.png`);
        }
        this.load('bg_1to2', 'background/background_1_to_2.png');
        this.load('bg_2to3', 'background/background_2_to_3.png');
        this.load('bg_3to4', 'background/background_3_to_4.png');
        this.load('bg_4to5', 'background/background_4_to_5.png');
        this.load('tower', 'background/demonkingstower.gif');

        // 이펙트
        this.load('arrow', 'effect/effect_arrow.png');
        this.load('beforegoblin', 'effect/effect_beforegoblin.png');
        this.load('goblin', 'effect/effect_goblin.png');
        for(let i = 1; i <= 5; i++) {
            this.load(`catch_${i}`, `effect/effect_catchhold_${i}.gif`);
        }
        this.load('lava_effect', 'effect/effect_lava.png');
        this.load('lava_sign', 'effect/effect_lava_sign.png');
        this.load('rock_effect', 'effect/effect_rock.png');
        this.load('rock_sign', 'effect/effect_rock_sign.png');
        this.load('wind', 'effect/effect_wind.png');

        // 홀드
        this.load('hold_basic', 'hold/hold_basic.png');
        this.load('hold_ice', 'hold/hold_ice.png');
        this.load('hold_lava', 'hold/hold_lava.png');
        this.load('hold_magic', 'hold/hold_magic.gif');
        this.load('hold_lava_appear', 'hold/hold_lava_appear.gif');
        this.load('hold_lava_disappear', 'hold/hold_lava_disappear.gif');
        this.load('hold_magic_appear', 'hold/hold_magic_appear.gif');
        this.load('hold_magic_disappear', 'hold/hold_magic_disappear.gif');
        this.load('hold_magic_location', 'hold/hold_magic_location.png');
        this.load('hold_lavabug', 'hold/hold_lavabug.gif');
        this.load('hold_rockbug', 'hold/hold_rockbug.gif');
        this.load('hold_snowbug', 'hold/hold_snowbug.gif');
        this.load('hold_trap', 'hold/hold_trap.png');

        // 플레이어
        this.load('player_left', 'player/player_left.gif');
        this.load('player_left_jump', 'player/player_left_jump.gif');
        this.load('player_right', 'player/player_right.gif');
        this.load('player_right_jump', 'player/player_right_jump.gif');
    }

    get(key) {
        return this.images[key];
    }

    isReady() {
        return this.loaded >= this.total;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = CONFIG.WIDTH;
        this.canvas.height = CONFIG.HEIGHT;
        
        this.loader = new ImageLoader();
        this.loader.loadAll();
        
        this.state = 'LOGIN';
        this.user = null;
        this.distance = 0;
        this.cameraY = 0;
        this.player = null;
        this.holds = [];
        this.rocks = [];
        this.goblins = [];
        this.lavas = [];
        this.timer = 0;
        this.wind = { active: false, direction: 0, timer: 0 };
        this.effects = []; // 이펙트 파티클
        this.transitionAlpha = 0; // 구간 전환 효과
        this.currentZoneIndex = 0;

        this.init();
        this.bindEvents();
    }

    init() {
        const saved = localStorage.getItem('ck_logged_in');
        if (saved) {
            this.user = JSON.parse(localStorage.getItem(`ck_user_${saved}`));
            this.showMenu();
        }
    }

    bindEvents() {
        this.canvas.addEventListener('mousedown', (e) => this.handleInput(e));
        this.canvas.addEventListener('touchstart', (e) => { 
            e.preventDefault(); 
            this.handleInput(e); 
        });
    }

    login() {
        const name = document.getElementById('username').value.trim();
        const pass = document.getElementById('password').value.trim();
        if(!name || !pass) return alert("입력해줘!");
        
        let data = localStorage.getItem(`ck_user_${name}`);
        if(data) {
            data = JSON.parse(data);
            if(data.pass !== pass) return alert("비밀번호 틀림!");
            this.user = data;
        } else {
            this.user = { name, pass, best: 0 };
        }
        localStorage.setItem('ck_logged_in', name);
        this.save();
        this.showMenu();
    }

    save() { 
        localStorage.setItem(`ck_user_${this.user.name}`, JSON.stringify(this.user)); 
    }
    
    logout() { 
        localStorage.removeItem('ck_logged_in'); 
        location.reload(); 
    }

    showMenu() {
        this.state = 'MENU';
        document.getElementById('login-screen').className = 'ui-layer hidden';
        document.getElementById('game-over').className = 'ui-layer hidden';
        document.getElementById('main-menu').className = 'ui-layer';
        document.getElementById('welcome-msg').innerText = `${this.user.name} 기사, 준비되었나?`;
        document.getElementById('best-dist').innerText = this.user.best;
    }

    start() {
        this.state = 'PLAYING';
        this.distance = 0;
        this.cameraY = 0;
        this.timer = 0;
        this.rocks = [];
        this.goblins = [];
        this.lavas = [];
        this.effects = [];
        this.wind = { active: false, direction: 0, timer: 0 };
        this.currentZoneIndex = 0;
        this.transitionAlpha = 0;
        
        document.getElementById('main-menu').className = 'ui-layer hidden';
        document.getElementById('game-over').className = 'ui-layer hidden';
        document.getElementById('hud').className = '';

        this.player = {
            x: CONFIG.WIDTH/2, 
            y: CONFIG.HEIGHT - 120, 
            vx: 0, 
            vy: 0, 
            radius: 25,
            onHold: null, 
            arrowAngle: 0, 
            arrowDir: 1, 
            grabReady: false,
            rotation: 0,
            facingLeft: false,
            isJumping: false
        };

        this.holds = [{ 
            x: CONFIG.WIDTH/2, 
            y: CONFIG.HEIGHT - 80, 
            type: 'normal', 
            active: true,
            timer: 0,
            originX: CONFIG.WIDTH/2,
            originY: CONFIG.HEIGHT - 80
        }];
        this.player.onHold = this.holds[0];
        
        for(let i = 0; i < 10; i++) this.spawnHold();
        this.loop();
    }

    handleInput() {
        if(this.state !== 'PLAYING') return;
        
        if(this.player.onHold) {
            // 점프
            const rad = (this.player.arrowAngle - 90) * Math.PI / 180;
            this.player.vx = CONFIG.JUMP_SPEED * Math.cos(rad);
            this.player.vy = CONFIG.JUMP_SPEED * Math.sin(rad);
            this.player.onHold = null;
            this.player.grabReady = false;
            this.player.isJumping = true;
            this.player.facingLeft = this.player.vx < 0;
            
            setTimeout(() => this.player.grabReady = true, 150);
        } else {
            // 잡기 시도
            const target = this.holds.find(h => {
                const d = Math.hypot(this.player.x - h.x, this.player.y - h.y);
                return h.active && d < CONFIG.HOLD_GRAB_DISTANCE && this.player.grabReady;
            });
            
            if(target) {
                this.player.onHold = target;
                this.player.vx = 0; 
                this.player.vy = 0;
                this.player.isJumping = false;
                this.player.rotation = 0;
                
                // 홀드 타입별 처리
                if(target.type === 'breaking') {
                    target.timer = 120; // 2초
                }
                if(target.type === 'trap') {
                    this.spawnGoblin(target);
                }
                
                // 캐치 이펙트
                const zoneIdx = this.getZoneIndex();
                this.addEffect(target.x, target.y, `catch_${zoneIdx + 1}`, 30);
            }
        }
    }

    spawnHold() {
        const last = this.holds[this.holds.length - 1];
        const zone = this.getZone();
        
        let newY = last.y - (CONFIG.HOLD_SPAWN_DISTANCE + Math.random() * 80);
        let newX;
        
        // x좌표는 이전 홀드와 반대편에 생성
        if(last.x < CONFIG.WIDTH / 2) {
            newX = CONFIG.WIDTH / 2 + Math.random() * (CONFIG.WIDTH / 2 - 60);
        } else {
            newX = 40 + Math.random() * (CONFIG.WIDTH / 2 - 60);
        }

        let type = this.getHoldType(zone);

        this.holds.push({ 
            x: newX, 
            y: newY, 
            type, 
            active: true, 
            timer: 0, 
            angle: Math.random() * Math.PI * 2,
            originX: newX, 
            originY: newY
        });
    }

    getHoldType(zone) {
        const rand = Math.random();
        
        if(zone === 'BASIC') {
            if(rand < 0.15) return 'breaking';
            return 'normal';
        } else if(zone === 'ROCK') {
            if(rand < 0.3) return 'rock_bug';
            if(rand < 0.5) return 'rock_bug_v';
            if(rand < 0.65) return 'breaking';
            return 'normal';
        } else if(zone === 'SNOW') {
            if(rand < 0.25) return 'snow_bug';
            if(rand < 0.45) return 'ice';
            if(rand < 0.6) return 'breaking';
            return 'normal';
        } else if(zone === 'LAVA') {
            if(rand < 0.25) return 'lava_bug';
            if(rand < 0.45) return 'lava';
            if(rand < 0.6) return 'breaking';
            return 'normal';
        } else { // CASTLE
            if(rand < 0.2) return 'magic';
            if(rand < 0.35) return 'trap';
            if(rand < 0.5) return 'breaking';
            return 'normal';
        }
    }

    spawnGoblin(hold) {
        // 트랩 홀드를 밟으면 2초 후 고블린 출현
        this.addEffect(hold.x, hold.y - 50, 'beforegoblin', 120);
        
        setTimeout(() => {
            if(this.state === 'PLAYING') {
                this.goblins.push({ 
                    x: hold.x, 
                    y: hold.y - 400, 
                    vy: 5 
                });
            }
        }, 2000);
    }

    getZone() {
        for(let zone of ZONES) {
            if(this.distance >= zone.start && this.distance < zone.end) {
                return zone.name;
            }
        }
        return 'CASTLE';
    }

    getZoneIndex() {
        for(let i = 0; i < ZONES.length; i++) {
            if(this.distance >= ZONES[i].start && this.distance < ZONES[i].end) {
                return i;
            }
        }
        return 4;
    }

    addEffect(x, y, imageKey, duration) {
        this.effects.push({
            x, y, imageKey, duration, timer: 0
        });
    }

    update() {
        this.timer++;
        const p = this.player;

        // 구간 전환 체크
        const newZoneIdx = this.getZoneIndex();
        if(newZoneIdx !== this.currentZoneIndex) {
            this.currentZoneIndex = newZoneIdx;
            this.transitionAlpha = 1.0; // 전환 효과 시작
        }
        if(this.transitionAlpha > 0) {
            this.transitionAlpha -= 0.02;
        }

        if(p.onHold) {
            // 홀드에 매달려 있을 때
            p.x = p.onHold.x;
            p.y = p.onHold.y;
            p.arrowAngle += 2 * p.arrowDir;
            if(Math.abs(p.arrowAngle) > CONFIG.ARROW_ANGLE_RANGE) {
                p.arrowDir *= -1;
            }
            
            // 부서지는 홀드
            if(p.onHold.type === 'breaking' && p.onHold.timer > 0) {
                p.onHold.timer--;
                if(p.onHold.timer <= 0) { 
                    p.onHold.active = false; 
                    p.onHold = null; 
                }
            }
            
            // 얼음 홀드 (미끄러짐)
            if(p.onHold.type === 'ice') {
                p.onHold.y += 1.5;
            }
        } else {
            // 공중에 있을 때
            p.vy += CONFIG.GRAVITY;
            
            // 바람 영향 (설산 구간)
            if(this.wind.active) {
                p.vx += this.wind.direction * 0.3;
            }
            
            p.x += p.vx; 
            p.y += p.vy;
            p.rotation += p.vx > 0 ? 5 : -5;
            
            // 벽 충돌 (튕김)
            if(p.x < p.radius || p.x > CONFIG.WIDTH - p.radius) {
                p.vx *= -0.6;
                p.x = p.x < p.radius ? p.radius : CONFIG.WIDTH - p.radius;
            }
        }

        // 카메라 추적
        let targetCam = p.y - CONFIG.HEIGHT * 0.6;
        this.cameraY += (targetCam - this.cameraY) * 0.1;

        // 홀드 업데이트
        this.holds.forEach(h => {
            // 움직이는 홀드들
            if(h.type === 'rock_bug') {
                h.x = h.originX + Math.sin(this.timer * 0.05) * 100;
            }
            if(h.type === 'rock_bug_v') {
                h.y = h.originY + Math.sin(this.timer * 0.05) * 80;
            }
            if(h.type === 'snow_bug') {
                h.x = h.originX + Math.sin(this.timer * 0.08) * 120;
            }
            if(h.type === 'lava_bug') {
                h.x = h.originX + Math.cos(this.timer * 0.1) * 80;
                h.y = h.originY + Math.sin(this.timer * 0.1) * 80;
            }
            
            // 깜빡이는 용암 홀드 (4초 보임, 2초 안보임)
            if(h.type === 'lava') {
                h.active = (this.timer % 360 < 240);
            }
            
            // 순간이동 마법 홀드
            if(h.type === 'magic') {
                if(this.timer % 90 === 0) {
                    h.x = h.originX + (Math.random() - 0.5) * 200;
                    h.y = h.originY + (Math.random() - 0.5) * 100;
                }
            }
        });

        // 구간별 장애물
        const zone = this.getZone();
        
        // 암석 지대: 돌 낙하
        if(zone === 'ROCK' && this.timer % 120 === 0) {
            const rockX = Math.random() * CONFIG.WIDTH;
            this.rocks.push({ 
                x: rockX, 
                y: this.cameraY - 50, 
                vy: 4 + Math.random() * 3 
            });
            this.addEffect(rockX, this.cameraY - 80, 'rock_sign', 60);
        }
        this.rocks.forEach(r => {
            r.y += r.vy;
            if(Math.hypot(p.x - r.x, p.y - r.y) < p.radius + 20) {
                this.die();
            }
        });

        // 설산 지대: 바람
        if(zone === 'SNOW') {
            this.wind.timer--;
            if(this.wind.timer <= 0) {
                this.wind.active = !this.wind.active;
                if(this.wind.active) {
                    this.wind.direction = Math.random() < 0.5 ? -1 : 1;
                    this.wind.timer = 180; // 3초
                } else {
                    this.wind.timer = 120; // 2초
                }
            }
        } else {
            this.wind.active = false;
        }

        // 용암 지대: 용암 낙하
        if(zone === 'LAVA' && this.timer % 100 === 0) {
            const lavaX = Math.random() * CONFIG.WIDTH;
            this.lavas.push({ 
                x: lavaX, 
                y: this.cameraY - 50, 
                vy: 6 + Math.random() * 2 
            });
            this.addEffect(lavaX, this.cameraY - 80, 'lava_sign', 50);
        }
        this.lavas.forEach(lava => {
            lava.y += lava.vy;
            if(Math.hypot(p.x - lava.x, p.y - lava.y) < p.radius + 25) {
                this.die();
            }
        });

        // 고블린 (마왕성 구간 및 트랩)
        this.goblins.forEach(g => {
            g.y += g.vy;
            if(Math.hypot(p.x - g.x, p.y - g.y) < p.radius + 25) {
                this.die();
            }
        });

        // 이펙트 업데이트
        this.effects = this.effects.filter(e => {
            e.timer++;
            return e.timer < e.duration;
        });

        // 거리 갱신
        this.distance = Math.max(this.distance, Math.floor((CONFIG.HEIGHT - 120 - p.y) / 10));
        document.getElementById('dist-txt').innerText = this.distance + "m";
        document.getElementById('zone-txt').innerText = this.getZone() + " ZONE";

        // 홀드 생성
        if(this.holds[this.holds.length - 1].y > p.y - 1000) {
            this.spawnHold();
        }

        // 게임 종료 조건
        if(p.y > this.cameraY + CONFIG.HEIGHT + 100) {
            this.die();
        }
        if(this.distance >= 10000) {
            this.win();
        }
    }

    die() {
        this.state = 'GAMEOVER';
        if(this.distance > this.user.best) { 
            this.user.best = this.distance; 
            this.save(); 
        }
        document.getElementById('over-title').innerText = "원정 실패";
        document.getElementById('over-title').style.color = "var(--danger)";
        document.getElementById('over-stats').innerText = `기록: ${this.distance}m\n목표: 10,000m`;
        document.getElementById('game-over').className = 'ui-layer';
    }

    win() {
        this.state = 'GAMEOVER';
        if(this.distance > this.user.best) { 
            this.user.best = this.distance; 
            this.save(); 
        }
        document.getElementById('over-title').innerText = "탑의 정복자!";
        document.getElementById('over-title').style.color = "var(--primary)";
        document.getElementById('over-stats').innerText = "축하합니다! 마왕성을 정복했습니다!";
        document.getElementById('game-over').className = 'ui-layer';
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

        // 배경 그리기
        this.drawBackground();

        // 바람 이펙트
        if(this.wind.active) {
            const windImg = this.loader.get('wind');
            if(windImg) {
                const windX = this.wind.direction > 0 ? 0 : CONFIG.WIDTH;
                ctx.save();
                ctx.globalAlpha = 0.5;
                if(this.wind.direction < 0) {
                    ctx.translate(CONFIG.WIDTH, 0);
                    ctx.scale(-1, 1);
                }
                ctx.drawImage(windImg, 0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
                ctx.restore();
            }
        }

        // 홀드 그리기
        this.holds.forEach(h => {
            if(!h.active) return;
            
            const screenY = h.y - this.cameraY;
            if(screenY < -100 || screenY > CONFIG.HEIGHT + 100) return;

            let img = this.loader.get('hold_basic');
            if(h.type === 'ice') img = this.loader.get('hold_ice');
            else if(h.type === 'lava') img = this.loader.get('hold_lava');
            else if(h.type === 'magic') img = this.loader.get('hold_magic');
            else if(h.type === 'trap') img = this.loader.get('hold_trap');
            else if(h.type === 'rock_bug' || h.type === 'rock_bug_v') img = this.loader.get('hold_rockbug');
            else if(h.type === 'snow_bug') img = this.loader.get('hold_snowbug');
            else if(h.type === 'lava_bug') img = this.loader.get('hold_lavabug');

            if(img) {
                const size = h.type === 'ice' ? 180 : 60;
                ctx.drawImage(img, h.x - size/2, screenY - size/2, size, size);
            } else {
                // Fallback
                ctx.fillStyle = this.getHoldColor(h.type);
                ctx.beginPath();
                if(h.type === 'ice') {
                    ctx.rect(h.x - 90, screenY - 20, 180, 40);
                } else {
                    ctx.arc(h.x, screenY, 30, 0, Math.PI * 2);
                }
                ctx.fill();
            }
            
            // 잡기 가능 표시
            if(!this.player.onHold && this.player.grabReady) {
                const d = Math.hypot(this.player.x - h.x, this.player.y - h.y);
                if(d < CONFIG.HOLD_GRAB_DISTANCE) {
                    ctx.strokeStyle = '#0f0'; 
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(h.x, screenY, 35, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // 부서지는 홀드 타이머 표시
            if(h.type === 'breaking' && h.timer > 0) {
                ctx.fillStyle = '#f44';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.ceil(h.timer / 60), h.x, screenY - 40);
            }
        });

        // 장애물 그리기
        this.rocks.forEach(r => {
            const img = this.loader.get('rock_effect');
            if(img) {
                ctx.drawImage(img, r.x - 20, r.y - this.cameraY - 20, 40, 40);
            } else {
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.arc(r.x, r.y - this.cameraY, 20, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        this.lavas.forEach(lava => {
            const img = this.loader.get('lava_effect');
            if(img) {
                ctx.drawImage(img, lava.x - 25, lava.y - this.cameraY - 25, 50, 50);
            } else {
                ctx.fillStyle = '#f80';
                ctx.beginPath();
                ctx.arc(lava.x, lava.y - this.cameraY, 25, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        this.goblins.forEach(g => {
            const img = this.loader.get('goblin');
            if(img) {
                ctx.drawImage(img, g.x - 25, g.y - this.cameraY - 25, 50, 50);
            } else {
                ctx.fillStyle = '#800';
                ctx.beginPath();
                ctx.arc(g.x, g.y - this.cameraY, 25, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        // 이펙트 그리기
        this.effects.forEach(e => {
            const img = this.loader.get(e.imageKey);
            if(img) {
                ctx.save();
                ctx.globalAlpha = 1 - (e.timer / e.duration);
                ctx.drawImage(img, e.x - 30, e.y - this.cameraY - 30, 60, 60);
                ctx.restore();
            }
        });

        // 플레이어 그리기
        this.drawPlayer();

        // 구간 전환 효과
        if(this.transitionAlpha > 0) {
            ctx.save();
            ctx.globalAlpha = this.transitionAlpha;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
            ctx.restore();
        }
    }

    drawBackground() {
        const ctx = this.ctx;
        const zoneIdx = this.getZoneIndex();
        
        const scale = CONFIG.WIDTH / 2880;
        const bg0Height = 1440 * scale;  // bg_0 높이
        const bgHeight = 6240 * scale;   // bg_1~5 높이
        const transHeight = 960 * scale; // 전환 이미지 높이
        
        // bg_0의 월드 좌표 (맨 바닥)
        const bg0WorldY = CONFIG.HEIGHT - 120;
        
        // === 1. 각 구간의 반복 배경 그리기 (bg_1~5) ===
        for(let z = 1; z <= 5; z++) {
            const zoneStart = ZONES[z - 1].start * 10; // 구간 시작 높이 (픽셀)
            const zoneEnd = ZONES[z - 1].end * 10;     // 구간 끝 높이
            
            // 구간 시작점 월드 좌표
            const zoneSplitY = bg0WorldY - zoneStart;
            
            const bg = this.loader.get(`bg_${z}`);
            if(!bg) continue;
            
            // 전환 이미지가 있으면 그 위부터 시작
            const startY = z > 1 ? (zoneSplitY - transHeight) : zoneSplitY;
            
            // 현재 카메라 위치 기준으로 타일링
            let currY = startY - bgHeight;
            
            // 위쪽으로 무한 반복
            while(currY - this.cameraY > -bgHeight - CONFIG.HEIGHT) {
                const screenY = currY - this.cameraY;
                
                // 화면에 보이는 것만 그리기
                if(screenY < CONFIG.HEIGHT) {
                    ctx.drawImage(bg, 0, screenY, CONFIG.WIDTH, bgHeight);
                }
                
                currY -= bgHeight;
                
                // 너무 많이 그리는 것 방지
                if(currY < this.cameraY - CONFIG.HEIGHT * 3) break;
            }
        }
        
        // === 2. bg_0 그리기 (맨 바닥에 한 번만) ===
        const bg0 = this.loader.get('bg_0');
        if(bg0) {
            const bg0ScreenY = (bg0WorldY - bg0Height) - this.cameraY;
            
            // 화면에 보일 때만
            if(bg0ScreenY > -bg0Height && bg0ScreenY < CONFIG.HEIGHT) {
                ctx.drawImage(bg0, 0, bg0ScreenY, CONFIG.WIDTH, bg0Height);
            }
        }
        
        // === 3. 구간 전환 이미지 그리기 (각 구간 경계에 한 번씩) ===
        for(let z = 1; z < ZONES.length; z++) {
            const splitPoint = ZONES[z].start * 10;
            const splitY = bg0WorldY - splitPoint;
            const transScreenY = (splitY - transHeight) - this.cameraY;
            
            // 화면에 보일 때만
            if(transScreenY > -transHeight && transScreenY < CONFIG.HEIGHT) {
                const transImg = this.loader.get(`bg_${z}to${z + 1}`);
                if(transImg) {
                    ctx.drawImage(transImg, 0, transScreenY, CONFIG.WIDTH, transHeight);
                }
            }
        }
    }

    drawPlayer() {
        const ctx = this.ctx;
        const p = this.player;
        const screenY = p.y - this.cameraY;

        ctx.save();
        ctx.translate(p.x, screenY);
        
        if(!p.onHold) {
            ctx.rotate(p.rotation * Math.PI / 180);
        }

        // 플레이어 이미지
        let playerImg = null;
        if(p.onHold) {
            playerImg = p.facingLeft ? this.loader.get('player_left') : this.loader.get('player_right');
        } else {
            playerImg = p.facingLeft ? this.loader.get('player_left_jump') : this.loader.get('player_right_jump');
        }

        if(playerImg) {
            ctx.drawImage(playerImg, -25, -25, 50, 50);
        } else {
            // Fallback
            ctx.fillStyle = '#fff';
            ctx.fillRect(-25, -25, 50, 50);
        }

        // 화살표 (홀드에 매달렸을 때만)
        if(p.onHold) {
            const arrowImg = this.loader.get('arrow');
            ctx.rotate(p.arrowAngle * Math.PI / 180);
            
            if(arrowImg) {
                ctx.drawImage(arrowImg, -10, -70, 20, 40);
            } else {
                // Fallback
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.moveTo(-5, -40);
                ctx.lineTo(0, -60);
                ctx.lineTo(5, -40);
                ctx.fill();
            }
        }

        ctx.restore();
    }

    getHoldColor(type) {
        switch(type) {
            case 'breaking': return '#f44';
            case 'ice': return '#9df';
            case 'lava': return '#f80';
            case 'magic': return '#a4f';
            case 'trap': return '#444';
            default: return '#853';
        }
    }

    loop() {
        if(this.state !== 'PLAYING') return;
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

const game = new Game();
</script>
</body>
</html>
