<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Climbing Knights - Dev Mode</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Noto+Sans+KR:wght@400;700&display=swap');
        :root { 
            --primary: #FFD700; 
            --danger: #FF4444; 
            --ui-bg: rgba(0, 0, 0, 0.9); 
            --dev-bg: rgba(0, 100, 255, 0.95);
        }
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Noto Sans KR', sans-serif; 
            color: white; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            touch-action: none; 
        }
        #main-wrapper {
            display: flex;
            gap: 0;
            height: 100vh;
            align-items: center;
        }
        #game-container { 
            position: relative; 
            width: 480px; 
            height: 100%; 
            background: #222; 
            overflow: hidden; 
            flex-shrink: 0;
        }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        .ui-layer { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            background: var(--ui-bg); 
            z-index: 10; 
            overflow-y: auto;
        }
        .hidden { 
            display: none !important; 
        }
        .box { 
            background: #333; 
            padding: 30px; 
            border-radius: 15px; 
            border: 2px solid var(--primary); 
            text-align: center; 
            width: 80%; 
            max-width: 400px;
        }
        input { 
            width: 100%; 
            padding: 12px; 
            margin: 10px 0; 
            border-radius: 5px; 
            border: none; 
            font-size: 16px; 
            box-sizing: border-box; 
        }
        button { 
            width: 100%; 
            padding: 15px; 
            margin-top: 15px; 
            border: none; 
            border-radius: 5px; 
            background: var(--primary); 
            color: black; 
            font-weight: bold; 
            cursor: pointer; 
            font-size: 18px; 
        }
        button:active {
            opacity: 0.8;
        }
        #hud { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 5; 
            font-family: 'Black Ops One', cursive; 
            font-size: 24px; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); 
            pointer-events: none; 
        }
        #zone-txt {
            font-size: 14px;
            color: var(--primary);
            margin-top: 5px;
        }
        
        /* ê°œë°œì íŒ¨ë„ ìŠ¤íƒ€ì¼ */
        #dev-panel {
            width: 320px;
            max-height: 100vh;
            background: var(--dev-bg);
            border-left: 2px solid #00f;
            padding: 15px;
            overflow-y: auto;
            font-size: 12px;
            flex-shrink: 0;
        }
        
        #dev-panel.minimized {
            width: 60px;
            overflow: hidden;
        }
        
        #dev-panel.minimized #dev-panel-content {
            display: none;
        }
        
        #dev-panel.minimized h3 {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            margin: 0;
        }
        
        @media (max-width: 800px) {
            #dev-panel {
                position: fixed;
                right: 0;
                top: 0;
                height: 100vh;
                z-index: 30;
                width: 280px;
            }
            #dev-panel.minimized {
                width: 40px;
            }
        }
        
        #dev-panel h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            white-space: nowrap;
        }
        
        #dev-panel.minimized h3 {
            flex-direction: column;
            gap: 10px;
            font-size: 12px;
            writing-mode: vertical-rl;
            text-orientation: upright;
            height: 150px;
            margin: auto;
        }
        
        #dev-panel.minimized .toggle-btn {
            writing-mode: horizontal-tb;
        }
        
        .dev-section {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        
        .dev-section h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #0ff;
        }
        
        .dev-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 5px 0;
        }
        
        .dev-control label {
            flex: 1;
            font-size: 11px;
        }
        
        .dev-control input[type="number"],
        .dev-control input[type="range"] {
            width: 100px;
            padding: 3px;
            font-size: 11px;
        }
        
        .dev-control input[type="range"] {
            width: 120px;
        }
        
        .dev-control .value-display {
            width: 50px;
            text-align: right;
            font-weight: bold;
            color: #0f0;
        }
        
        .dev-button {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: #0080ff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .dev-button:hover {
            background: #0060cc;
        }
        
        .dev-button.danger {
            background: #ff4444;
        }
        
        .dev-button.danger:hover {
            background: #cc0000;
        }
        
        .toggle-btn {
            padding: 2px 8px;
            background: #444;
            border: none;
            border-radius: 3px;
            color: white;
            cursor: pointer;
            font-size: 10px;
        }
        
        #dev-mode-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--dev-bg);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 6;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="main-wrapper">
<div id="game-container">
    <div id="hud" class="hidden">
        <div id="dist-txt">0m</div>
        <div id="zone-txt">BASIC ZONE</div>
    </div>
    
    <div id="dev-mode-badge" class="hidden">ğŸ”§ DEV MODE</div>

    <div id="login-screen" class="ui-layer">
        <h1 style="font-family: 'Black Ops One'; color: var(--primary); font-size: 40px; margin-bottom: 5px;">CLIMBING KNIGHTS</h1>
        <p style="margin-bottom: 20px; color: #aaa;">ì›í„°ì¹˜ íƒ‘ ë“±ë°˜ ê²Œì„</p>
        <div class="box">
            <input type="text" id="username" placeholder="ìœ ì €ëª…">
            <input type="password" id="password" placeholder="ë¹„ë°€ë²ˆí˜¸">
            <button onclick="game.login()">Login</button>
        </div>
    </div>

    <div id="main-menu" class="ui-layer hidden">
        <h2 id="welcome-msg" style="color: var(--primary);">ë‹˜, ì•ˆë…•í•˜ì„¸ìš”!</h2>
        <p>ìµœê³  ê¸°ë¡: <span id="best-dist">0</span>m</p>
        <button style="width: 220px;" onclick="game.start()">ìŠ¤í† ë¦¬ ëª¨ë“œ ì‹œì‘</button>
        <button style="width: 220px; background: #555; color: white;" onclick="game.logout()">ë¡œê·¸ì•„ì›ƒ</button>
    </div>

    <div id="game-over" class="ui-layer hidden">
        <h1 id="over-title" style="color: var(--danger); font-size: 40px;">GAME OVER</h1>
        <p id="over-stats"></p>
        <button style="width: 200px;" onclick="game.start()">ì¬ë„ì „</button>
        <button style="width: 200px; background: #555; color: white;" onclick="game.showMenu()">ë©”ë‰´ë¡œ</button>
    </div>

    <canvas id="gameCanvas"></canvas>
</div>
    
    <!-- ê°œë°œì íŒ¨ë„ - ê²Œì„ ì»¨í…Œì´ë„ˆ ë°– -->
    <div id="dev-panel" class="hidden">
        <h3>
            ê°œë°œì íŒ¨ë„
            <button class="toggle-btn" onclick="game.toggleDevPanel()">â–¶</button>
        </h3>
        
        <div id="dev-panel-content">
            <div class="dev-section">
                <h4>âš™ï¸ ë¬¼ë¦¬ ì„¤ì •</h4>
                <div class="dev-control">
                    <label>ì¤‘ë ¥ (GRAVITY)</label>
                    <input type="range" min="0" max="1" step="0.05" value="0.35" 
                           oninput="game.updateConfig('GRAVITY', this.value)">
                    <span class="value-display" id="val-GRAVITY">0.35</span>
                </div>
                <div class="dev-control">
                    <label>ì í”„ ì†ë„ (JUMP_SPEED)</label>
                    <input type="range" min="10" max="30" step="1" value="16" 
                           oninput="game.updateConfig('JUMP_SPEED', this.value)">
                    <span class="value-display" id="val-JUMP_SPEED">16</span>
                </div>
            </div>
            
            <div class="dev-section">
                <h4>ğŸ¯ ê²Œì„í”Œë ˆì´</h4>
                <div class="dev-control">
                    <label>í™”ì‚´í‘œ ê°ë„ (Â°)</label>
                    <input type="range" min="30" max="90" step="5" value="60" 
                           oninput="game.updateConfig('ARROW_ANGLE_RANGE', this.value)">
                    <span class="value-display" id="val-ARROW_ANGLE_RANGE">60</span>
                </div>
                <div class="dev-control">
                    <label>ì¡ê¸° ê±°ë¦¬</label>
                    <input type="range" min="30" max="100" step="5" value="55" 
                           oninput="game.updateConfig('HOLD_GRAB_DISTANCE', this.value)">
                    <span class="value-display" id="val-HOLD_GRAB_DISTANCE">55</span>
                </div>
                <div class="dev-control">
                    <label>í™€ë“œ ìƒì„± ê±°ë¦¬</label>
                    <input type="range" min="100" max="300" step="10" value="180" 
                           oninput="game.updateConfig('HOLD_SPAWN_DISTANCE', this.value)">
                    <span class="value-display" id="val-HOLD_SPAWN_DISTANCE">180</span>
                </div>
            </div>
            
            <div class="dev-section">
                <h4>ğŸ² í™•ë¥  ì¡°ì •</h4>
                <div class="dev-control">
                    <label>íŠ¹ìˆ˜ í™€ë“œ í™•ë¥  (%)</label>
                    <input type="range" min="0" max="100" step="5" value="30" 
                           oninput="game.updateConfig('SPECIAL_HOLD_CHANCE', this.value)">
                    <span class="value-display" id="val-SPECIAL_HOLD_CHANCE">30</span>
                </div>
                <div class="dev-control">
                    <label>ë¶€ì„œì§€ëŠ” í™€ë“œ (%)</label>
                    <input type="range" min="0" max="50" step="5" value="15" 
                           oninput="game.updateConfig('BREAKING_HOLD_CHANCE', this.value)">
                    <span class="value-display" id="val-BREAKING_HOLD_CHANCE">15</span>
                </div>
            </div>
            
            <div class="dev-section">
                <h4>â±ï¸ íƒ€ì´ë°</h4>
                <div class="dev-control">
                    <label>ë¶€ì„œì§€ëŠ” í™€ë“œ ì‹œê°„ (í”„ë ˆì„)</label>
                    <input type="range" min="30" max="300" step="30" value="120" 
                           oninput="game.updateConfig('BREAKING_HOLD_DURATION', this.value)">
                    <span class="value-display" id="val-BREAKING_HOLD_DURATION">120</span>
                </div>
                <div class="dev-control">
                    <label>ë°”ìœ„ ìƒì„± ì£¼ê¸°</label>
                    <input type="range" min="60" max="300" step="30" value="120" 
                           oninput="game.updateConfig('ROCK_SPAWN_INTERVAL', this.value)">
                    <span class="value-display" id="val-ROCK_SPAWN_INTERVAL">120</span>
                </div>
                <div class="dev-control">
                    <label>ìš©ì•” ìƒì„± ì£¼ê¸°</label>
                    <input type="range" min="50" max="200" step="10" value="100" 
                           oninput="game.updateConfig('LAVA_SPAWN_INTERVAL', this.value)">
                    <span class="value-display" id="val-LAVA_SPAWN_INTERVAL">100</span>
                </div>
            </div>
            
            <div class="dev-section">
                <h4>ğŸš€ ì¹˜íŠ¸</h4>
                <button class="dev-button" onclick="game.devTeleport(2000)">ë°”ìœ„ êµ¬ê°„ìœ¼ë¡œ ì›Œí”„</button>
                <button class="dev-button" onclick="game.devTeleport(4000)">ì„¤ì‚° êµ¬ê°„ìœ¼ë¡œ ì›Œí”„</button>
                <button class="dev-button" onclick="game.devTeleport(6000)">ìš©ì•” êµ¬ê°„ìœ¼ë¡œ ì›Œí”„</button>
                <button class="dev-button" onclick="game.devTeleport(8000)">ë§ˆì™•ì„±ìœ¼ë¡œ ì›Œí”„</button>
                <button class="dev-button" onclick="game.devTeleport(9900)">ê±°ì˜ í´ë¦¬ì–´</button>
                <button class="dev-button" onclick="game.devGodMode()">ë¬´ì  ëª¨ë“œ í† ê¸€</button>
                <button class="dev-button danger" onclick="game.devClearProgress()">ì§„í–‰ë„ ì´ˆê¸°í™”</button>
            </div>
            
            <div class="dev-section">
                <h4>ğŸ“Š ë””ë²„ê·¸ ì •ë³´</h4>
                <div style="font-size: 11px; line-height: 1.5;">
                    <div>ê±°ë¦¬: <span id="debug-distance">0</span>m</div>
                    <div>í™€ë“œ ìˆ˜: <span id="debug-holds">0</span></div>
                    <div>ì¥ì• ë¬¼: <span id="debug-obstacles">0</span></div>
                    <div>FPS: <span id="debug-fps">60</span></div>
                    <div>ì¹´ë©”ë¼Y: <span id="debug-camera">0</span></div>
                    <div>ë¬´ì : <span id="debug-godmode">OFF</span></div>
                </div>
            </div>
            
            <button class="dev-button" onclick="game.devReset()">ì„¤ì • ì´ˆê¸°í™”</button>
        </div>
    </div>
</div>

</div>

<script>
/**
 * Climbing Knights - Developer Mode
 */

const CONFIG = {
    WIDTH: 480, 
    HEIGHT: 854,
    GRAVITY: 0.35, 
    JUMP_SPEED: 16,
    ARROW_ANGLE_RANGE: 60,
    HOLD_GRAB_DISTANCE: 55,
    HOLD_SPAWN_DISTANCE: 180,
    SPECIAL_HOLD_CHANCE: 30,
    BREAKING_HOLD_CHANCE: 15,
    BREAKING_HOLD_DURATION: 120,
    ROCK_SPAWN_INTERVAL: 120,
    LAVA_SPAWN_INTERVAL: 100,
};

const DEFAULT_CONFIG = {...CONFIG};

const ZONES = [
    { name: 'BASIC', start: 0, end: 2000, bgIndex: 0 },
    { name: 'ROCK', start: 2000, end: 4000, bgIndex: 1 },
    { name: 'SNOW', start: 4000, end: 6000, bgIndex: 2 },
    { name: 'LAVA', start: 6000, end: 8000, bgIndex: 3 },
    { name: 'CASTLE', start: 8000, end: 10000, bgIndex: 4 }
];

class ImageLoader {
    constructor() {
        this.images = {};
        this.loaded = 0;
        this.total = 0;
        this.basePath = 'assets/';
    }

    load(key, path) {
        this.total++;
        const img = new Image();
        img.onload = () => {
            this.loaded++;
            this.images[key] = img;
        };
        img.onerror = () => {
            console.warn(`Failed to load: ${path}`);
            this.loaded++;
        };
        img.src = this.basePath + path;
        return img;
    }

    loadAll() {
        for(let i = 0; i <= 5; i++) {
            this.load(`bg_${i}`, `background/background_${i}.png`);
        }
        this.load('bg_1to2', 'background/background_1_to_2.png');
        this.load('bg_2to3', 'background/background_2_to_3.png');
        this.load('bg_3to4', 'background/background_3_to_4.png');
        this.load('bg_4to5', 'background/background_4_to_5.png');
        this.load('tower', 'background/demonkingstower.gif');

        this.load('arrow', 'effect/effect_arrow.png');
        this.load('beforegoblin', 'effect/effect_beforegoblin.png');
        this.load('goblin', 'effect/effect_goblin.png');
        for(let i = 1; i <= 5; i++) {
            this.load(`catch_${i}`, `effect/effect_catchhold_${i}.gif`);
        }
        this.load('lava_effect', 'effect/effect_lava.png');
        this.load('lava_sign', 'effect/effect_lava_sign.png');
        this.load('rock_effect', 'effect/effect_rock.png');
        this.load('rock_sign', 'effect/effect_rock_sign.png');
        this.load('wind', 'effect/effect_wind.png');

        this.load('hold_basic', 'hold/hold_basic.png');
        this.load('hold_ice', 'hold/hold_ice.png');
        this.load('hold_lava', 'hold/hold_lava.png');
        this.load('hold_magic', 'hold/hold_magic.gif');
        this.load('hold_lava_appear', 'hold/hold_lava_appear.gif');
        this.load('hold_lava_disappear', 'hold/hold_lava_disappear.gif');
        this.load('hold_magic_appear', 'hold/hold_magic_appear.gif');
        this.load('hold_magic_disappear', 'hold/hold_magic_disappear.gif');
        this.load('hold_magic_location', 'hold/hold_magic_location.png');
        this.load('hold_lavabug', 'hold/hold_lavabug.gif');
        this.load('hold_rockbug', 'hold/hold_rockbug.gif');
        this.load('hold_snowbug', 'hold/hold_snowbug.gif');
        this.load('hold_trap', 'hold/hold_trap.png');

        this.load('player_left', 'player/player_left.gif');
        this.load('player_left_jump', 'player/player_left_jump.gif');
        this.load('player_right', 'player/player_right.gif');
        this.load('player_right_jump', 'player/player_right_jump.gif');
    }

    get(key) {
        return this.images[key];
    }

    isReady() {
        return this.loaded >= this.total;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = CONFIG.WIDTH;
        this.canvas.height = CONFIG.HEIGHT;
        
        this.loader = new ImageLoader();
        this.loader.loadAll();
        
        this.state = 'LOGIN';
        this.user = null;
        this.distance = 0;
        this.cameraY = 0;
        this.player = null;
        this.holds = [];
        this.rocks = [];
        this.goblins = [];
        this.lavas = [];
        this.timer = 0;
        this.wind = { active: false, direction: 0, timer: 0 };
        this.effects = [];
        this.transitionAlpha = 0;
        this.currentZoneIndex = 0;
        
        // ê°œë°œì ëª¨ë“œ
        this.devMode = false;
        this.godMode = false;
        this.lastFrameTime = Date.now();
        this.fps = 60;
        this.devPanelMinimized = false;

        this.init();
        this.bindEvents();
    }

    init() {
        const saved = localStorage.getItem('ck_logged_in');
        if (saved) {
            const userData = JSON.parse(localStorage.getItem(`ck_user_${saved}`));
            if (userData) {
                this.user = userData;
                this.devMode = (saved === 'dev');
                this.showMenu();
            }
        }
    }

    bindEvents() {
        this.canvas.addEventListener('mousedown', (e) => this.handleInput(e));
        this.canvas.addEventListener('touchstart', (e) => { 
            e.preventDefault(); 
            this.handleInput(e); 
        });
    }

    login() {
        const name = document.getElementById('username').value.trim();
        const pass = document.getElementById('password').value.trim();
        if(!name || !pass) return alert("ì…ë ¥í•´ì¤˜!");
        
        let data = localStorage.getItem(`ck_user_${name}`);
        if(data) {
            data = JSON.parse(data);
            if(data.pass !== pass) return alert("ë¹„ë°€ë²ˆí˜¸ í‹€ë¦¼!");
            this.user = data;
        } else {
            this.user = { name, pass, best: 0 };
        }
        
        this.devMode = (name === 'dev');
        
        localStorage.setItem('ck_logged_in', name);
        this.save();
        this.showMenu();
    }

    save() { 
        localStorage.setItem(`ck_user_${this.user.name}`, JSON.stringify(this.user)); 
    }
    
    logout() { 
        localStorage.removeItem('ck_logged_in'); 
        location.reload(); 
    }

    showMenu() {
        this.state = 'MENU';
        document.getElementById('login-screen').className = 'ui-layer hidden';
        document.getElementById('game-over').className = 'ui-layer hidden';
        document.getElementById('main-menu').className = 'ui-layer';
        document.getElementById('welcome-msg').innerText = `${this.user.name} ë‹˜, ì•ˆë…•í•˜ì„¸ìš”!`;
        document.getElementById('best-dist').innerText = this.user.best;
        
        if(this.devMode) {
            document.getElementById('dev-panel').className = '';
            document.getElementById('dev-mode-badge').className = '';
        }
    }

    start() {
        this.state = 'PLAYING';
        this.distance = 0;
        this.cameraY = 0;
        this.timer = 0;
        this.rocks = [];
        this.goblins = [];
        this.lavas = [];
        this.effects = [];
        this.wind = { active: false, direction: 0, timer: 0 };
        this.currentZoneIndex = 0;
        this.transitionAlpha = 0;
        
        document.getElementById('main-menu').className = 'ui-layer hidden';
        document.getElementById('game-over').className = 'ui-layer hidden';
        document.getElementById('hud').className = '';

        this.player = {
            x: CONFIG.WIDTH/2, 
            y: CONFIG.HEIGHT - 120, 
            vx: 0, 
            vy: 0, 
            radius: 25,
            onHold: null, 
            arrowAngle: 0, 
            arrowDir: 1, 
            grabReady: false,
            rotation: 0,
            facingLeft: false,
            isJumping: false
        };

        this.holds = [{ 
            x: CONFIG.WIDTH/2, 
            y: CONFIG.HEIGHT - 60, 
            type: 'normal', 
            active: true,
            timer: 0,
            originX: CONFIG.WIDTH/2,
            originY: CONFIG.HEIGHT - 80
        }];
        this.player.onHold = this.holds[0];
        
        for(let i = 0; i < 10; i++) this.spawnHold();
        this.loop();
    }

    handleInput() {
        if(this.state !== 'PLAYING') return;
        
        if(this.player.onHold) {
            const rad = (this.player.arrowAngle - 90) * Math.PI / 180;
            this.player.vx = CONFIG.JUMP_SPEED * Math.cos(rad);
            this.player.vy = CONFIG.JUMP_SPEED * Math.sin(rad);
            this.player.onHold = null;
            this.player.grabReady = false;
            this.player.isJumping = true;
            this.player.facingLeft = this.player.vx < 0;
            
            setTimeout(() => this.player.grabReady = true, 150);
        } else {
            const target = this.holds.find(h => {
                const d = Math.hypot(this.player.x - h.x, this.player.y - h.y);
                return h.active && d < CONFIG.HOLD_GRAB_DISTANCE && this.player.grabReady;
            });
            
            if(target) {
                this.player.onHold = target;
                this.player.vx = 0; 
                this.player.vy = 0;
                this.player.isJumping = false;
                this.player.rotation = 0;
                
                if(target.type === 'breaking') {
                    target.timer = CONFIG.BREAKING_HOLD_DURATION;
                }
                if(target.type === 'trap') {
                    this.spawnGoblin(target);
                }
                
                const zoneIdx = this.getZoneIndex();
                this.addEffect(target.x, target.y, `catch_${zoneIdx + 1}`, 30);
            }
        }
    }

    spawnHold() {
        const last = this.holds[this.holds.length - 1];
        const zone = this.getZone();
        
        let newY = last.y - (CONFIG.HOLD_SPAWN_DISTANCE + Math.random() * 80);
        let newX;
        
        if(last.x < CONFIG.WIDTH / 2) {
            newX = CONFIG.WIDTH / 2 + Math.random() * (CONFIG.WIDTH / 2 - 60);
        } else {
            newX = 40 + Math.random() * (CONFIG.WIDTH / 2 - 60);
        }

        let type = this.getHoldType(zone);

        this.holds.push({ 
            x: newX, 
            y: newY, 
            type, 
            active: true, 
            timer: 0, 
            angle: Math.random() * Math.PI * 2,
            originX: newX, 
            originY: newY
        });
    }

    getHoldType(zone) {
        const rand = Math.random() * 100;
        const specialChance = CONFIG.SPECIAL_HOLD_CHANCE;
        const breakingChance = CONFIG.BREAKING_HOLD_CHANCE;
        
        if(zone === 'BASIC') {
            if(rand < breakingChance) return 'breaking';
            return 'normal';
        } else if(zone === 'ROCK') {
            if(rand < specialChance * 0.6) return 'rock_bug';
            if(rand < specialChance) return 'rock_bug_v';
            if(rand < specialChance + breakingChance) return 'breaking';
            return 'normal';
        } else if(zone === 'SNOW') {
            if(rand < specialChance * 0.5) return 'snow_bug';
            if(rand < specialChance) return 'ice';
            if(rand < specialChance + breakingChance) return 'breaking';
            return 'normal';
        } else if(zone === 'LAVA') {
            if(rand < specialChance * 0.5) return 'lava_bug';
            if(rand < specialChance) return 'lava';
            if(rand < specialChance + breakingChance) return 'breaking';
            return 'normal';
        } else {
            if(rand < specialChance * 0.4) return 'magic';
            if(rand < specialChance * 0.7) return 'trap';
            if(rand < specialChance) return 'breaking';
            return 'normal';
        }
    }

    spawnGoblin(hold) {
        this.addEffect(hold.x, hold.y - 50, 'beforegoblin', 120);
        
        setTimeout(() => {
            if(this.state === 'PLAYING') {
                this.goblins.push({ 
                    x: hold.x, 
                    y: hold.y - 400, 
                    vy: 5 
                });
            }
        }, 2000);
    }

    getZone() {
        for(let zone of ZONES) {
            if(this.distance >= zone.start && this.distance < zone.end) {
                return zone.name;
            }
        }
        return 'CASTLE';
    }

    getZoneIndex() {
        for(let i = 0; i < ZONES.length; i++) {
            if(this.distance >= ZONES[i].start && this.distance < ZONES[i].end) {
                return i;
            }
        }
        return 4;
    }

    addEffect(x, y, imageKey, duration) {
        this.effects.push({
            x, y, imageKey, duration, timer: 0
        });
    }

    update() {
        this.timer++;
        const p = this.player;

        const newZoneIdx = this.getZoneIndex();
        if(newZoneIdx !== this.currentZoneIndex) {
            this.currentZoneIndex = newZoneIdx;
            this.transitionAlpha = 1.0;
        }
        if(this.transitionAlpha > 0) {
            this.transitionAlpha -= 0.02;
        }

        if(p.onHold) {
            p.x = p.onHold.x;
            p.y = p.onHold.y;
            p.arrowAngle += 2 * p.arrowDir;
            if(Math.abs(p.arrowAngle) > CONFIG.ARROW_ANGLE_RANGE) {
                p.arrowDir *= -1;
            }
            
            if(p.onHold.type === 'breaking' && p.onHold.timer > 0) {
                p.onHold.timer--;
                if(p.onHold.timer <= 0) { 
                    p.onHold.active = false; 
                    p.onHold = null; 
                }
            }
            
            if(p.onHold.type === 'ice') {
                p.onHold.y += 1.5;
            }
        } else {
            p.vy += CONFIG.GRAVITY;
            
            if(this.wind.active) {
                p.vx += this.wind.direction * 0.3;
            }
            
            p.x += p.vx; 
            p.y += p.vy;
            p.rotation += p.vx > 0 ? 5 : -5;
            
            if(p.x < p.radius || p.x > CONFIG.WIDTH - p.radius) {
                p.vx *= -0.6;
                p.x = p.x < p.radius ? p.radius : CONFIG.WIDTH - p.radius;
            }
        }

        const followLine = CONFIG.HEIGHT * 0.6;
        const playerScreenY = p.y - this.cameraY;

        if (playerScreenY < followLine) {
            const target = p.y - followLine;
            this.cameraY += (target - this.cameraY) * 0.1;
        }

        this.holds.forEach(h => {
            if(h.type === 'rock_bug') {
                h.x = h.originX + Math.sin(this.timer * 0.05) * 100;
            }
            if(h.type === 'rock_bug_v') {
                h.y = h.originY + Math.sin(this.timer * 0.05) * 80;
            }
            if(h.type === 'snow_bug') {
                h.x = h.originX + Math.sin(this.timer * 0.08) * 120;
            }
            if(h.type === 'lava_bug') {
                h.x = h.originX + Math.cos(this.timer * 0.1) * 80;
                h.y = h.originY + Math.sin(this.timer * 0.1) * 80;
            }
            
            if(h.type === 'lava') {
                h.active = (this.timer % 360 < 240);
            }
            
            if(h.type === 'magic') {
                if(this.timer % 90 === 0) {
                    h.x = h.originX + (Math.random() - 0.5) * 200;
                    h.y = h.originY + (Math.random() - 0.5) * 100;
                }
            }
        });

        const zone = this.getZone();
        
        if(zone === 'ROCK' && this.timer % CONFIG.ROCK_SPAWN_INTERVAL === 0) {
            const rockX = Math.random() * CONFIG.WIDTH;
            this.rocks.push({ 
                x: rockX, 
                y: this.cameraY - 50, 
                vy: 4 + Math.random() * 3 
            });
            this.addEffect(rockX, this.cameraY - 80, 'rock_sign', 60);
        }
        this.rocks.forEach(r => {
            r.y += r.vy;
            if(!this.godMode && Math.hypot(p.x - r.x, p.y - r.y) < p.radius + 20) {
                this.die();
            }
        });

        if(zone === 'SNOW') {
            this.wind.timer--;
            if(this.wind.timer <= 0) {
                this.wind.active = !this.wind.active;
                if(this.wind.active) {
                    this.wind.direction = Math.random() < 0.5 ? -1 : 1;
                    this.wind.timer = 180;
                } else {
                    this.wind.timer = 120;
                }
            }
        } else {
            this.wind.active = false;
        }

        if(zone === 'LAVA' && this.timer % CONFIG.LAVA_SPAWN_INTERVAL === 0) {
            const lavaX = Math.random() * CONFIG.WIDTH;
            this.lavas.push({ 
                x: lavaX, 
                y: this.cameraY - 50, 
                vy: 6 + Math.random() * 2 
            });
            this.addEffect(lavaX, this.cameraY - 80, 'lava_sign', 50);
        }
        this.lavas.forEach(lava => {
            lava.y += lava.vy;
            if(!this.godMode && Math.hypot(p.x - lava.x, p.y - lava.y) < p.radius + 25) {
                this.die();
            }
        });

        this.goblins.forEach(g => {
            g.y += g.vy;
            if(!this.godMode && Math.hypot(p.x - g.x, p.y - g.y) < p.radius + 25) {
                this.die();
            }
        });

        this.effects = this.effects.filter(e => {
            e.timer++;
            return e.timer < e.duration;
        });

        this.distance = Math.max(this.distance, Math.floor((CONFIG.HEIGHT - 120 - p.y) / 10));
        document.getElementById('dist-txt').innerText = this.distance + "m";
        document.getElementById('zone-txt').innerText = this.getZone() + " ZONE";

        if(this.holds[this.holds.length - 1].y > p.y - 1000) {
            this.spawnHold();
        }

        if(!this.godMode && p.y > this.cameraY + CONFIG.HEIGHT + 100) {
            this.die();
        }
        if(this.distance >= 10000) {
            this.win();
        }
        
        // ê°œë°œì ì •ë³´ ì—…ë°ì´íŠ¸
        if(this.devMode) {
            this.updateDevInfo();
        }
    }

    die() {
        this.state = 'GAMEOVER';
        if(this.distance > this.user.best) { 
            this.user.best = this.distance; 
            this.save(); 
        }
        document.getElementById('over-title').innerText = "ì›ì • ì‹¤íŒ¨";
        document.getElementById('over-title').style.color = "var(--danger)";
        document.getElementById('over-stats').innerText = `ê¸°ë¡: ${this.distance}m\nëª©í‘œ: 10,000m`;
        document.getElementById('game-over').className = 'ui-layer';
    }

    win() {
        this.state = 'GAMEOVER';
        if(this.distance > this.user.best) { 
            this.user.best = this.distance; 
            this.save(); 
        }
        document.getElementById('over-title').innerText = "CLEAR!";
        document.getElementById('over-title').style.color = "var(--primary)";
        document.getElementById('over-stats').innerText = "ì¶•í•˜í•©ë‹ˆë‹¤! ë§ˆì™•ì„±ì„ ì •ë³µí–ˆìŠµë‹ˆë‹¤!";
        document.getElementById('game-over').className = 'ui-layer';
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

        this.drawBackground();

        if(this.wind.active) {
            const windImg = this.loader.get('wind');
            if(windImg) {
                ctx.save();
                ctx.globalAlpha = 0.5;
                if(this.wind.direction < 0) {
                    ctx.translate(CONFIG.WIDTH, 0);
                    ctx.scale(-1, 1);
                }
                ctx.drawImage(windImg, 0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
                ctx.restore();
            }
        }

        this.holds.forEach(h => {
            if(!h.active) return;
            
            const screenY = h.y - this.cameraY;
            if(screenY < -100 || screenY > CONFIG.HEIGHT + 100) return;

            let img = this.loader.get('hold_basic');
            if(h.type === 'ice') img = this.loader.get('hold_ice');
            else if(h.type === 'lava') img = this.loader.get('hold_lava');
            else if(h.type === 'magic') img = this.loader.get('hold_magic');
            else if(h.type === 'trap') img = this.loader.get('hold_trap');
            else if(h.type === 'rock_bug' || h.type === 'rock_bug_v') img = this.loader.get('hold_rockbug');
            else if(h.type === 'snow_bug') img = this.loader.get('hold_snowbug');
            else if(h.type === 'lava_bug') img = this.loader.get('hold_lavabug');

            if(img) {
                const size = h.type === 'ice' ? 180 : 60;
                ctx.drawImage(img, h.x - size/2, screenY - size/2, size, size);
            } else {
                ctx.fillStyle = this.getHoldColor(h.type);
                ctx.beginPath();
                if(h.type === 'ice') {
                    ctx.rect(h.x - 90, screenY - 20, 180, 40);
                } else {
                    ctx.arc(h.x, screenY, 30, 0, Math.PI * 2);
                }
                ctx.fill();
            }
            
            if(!this.player.onHold && this.player.grabReady) {
                const d = Math.hypot(this.player.x - h.x, this.player.y - h.y);
                if(d < CONFIG.HOLD_GRAB_DISTANCE) {
                    ctx.strokeStyle = '#0f0'; 
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(h.x, screenY, 35, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            if(h.type === 'breaking' && h.timer > 0) {
                ctx.fillStyle = '#f44';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.ceil(h.timer / 60), h.x, screenY - 40);
            }
        });

        this.rocks.forEach(r => {
            const img = this.loader.get('rock_effect');
            if(img) {
                ctx.drawImage(img, r.x - 20, r.y - this.cameraY - 20, 40, 40);
            } else {
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.arc(r.x, r.y - this.cameraY, 20, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        this.lavas.forEach(lava => {
            const img = this.loader.get('lava_effect');
            if(img) {
                ctx.drawImage(img, lava.x - 25, lava.y - this.cameraY - 25, 50, 50);
            } else {
                ctx.fillStyle = '#f80';
                ctx.beginPath();
                ctx.arc(lava.x, lava.y - this.cameraY, 25, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        this.goblins.forEach(g => {
            const img = this.loader.get('goblin');
            if(img) {
                ctx.drawImage(img, g.x - 25, g.y - this.cameraY - 25, 50, 50);
            } else {
                ctx.fillStyle = '#800';
                ctx.beginPath();
                ctx.arc(g.x, g.y - this.cameraY, 25, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        this.effects.forEach(e => {
            const img = this.loader.get(e.imageKey);
            if(img) {
                ctx.save();
                ctx.globalAlpha = 1 - (e.timer / e.duration);
                ctx.drawImage(img, e.x - 30, e.y - this.cameraY - 30, 60, 60);
                ctx.restore();
            }
        });

        this.drawPlayer();

        if(this.transitionAlpha > 0) {
            ctx.save();
            ctx.globalAlpha = this.transitionAlpha;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
            ctx.restore();
        }
        
        // ë¬´ì  ëª¨ë“œ í‘œì‹œ
        if(this.godMode) {
            ctx.save();
            ctx.globalAlpha = 0.3 + Math.sin(this.timer * 0.1) * 0.3;
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
            ctx.restore();
        }
    }

    drawBackground() {
        const ctx = this.ctx;
        const zoneIdx = this.getZoneIndex();
        
        const scale = CONFIG.WIDTH / 2880;
        const bg0Height = 1440 * scale;
        const bgHeight = 6240 * scale;
        const transHeight = 960 * scale;
        
        const bg0WorldY = CONFIG.HEIGHT - 80;
        
        for(let z = 1; z <= 5; z++) {
            const zoneStart = ZONES[z - 1].start * 10;
            const zoneEnd = ZONES[z - 1].end * 10;
            
            const zoneSplitY = bg0WorldY - zoneStart;
            
            const bg = this.loader.get(`bg_${z}`);
            if(!bg) continue;
            
            const startY = z > 1 ? (zoneSplitY - transHeight) : zoneSplitY;
            
            let currY = startY - bgHeight;
            
            while(currY - this.cameraY > -bgHeight - CONFIG.HEIGHT) {
                const screenY = currY - this.cameraY;
                
                if(screenY < CONFIG.HEIGHT) {
                    ctx.drawImage(bg, 0, screenY, CONFIG.WIDTH, bgHeight);
                }
                
                currY -= bgHeight;
                
                if(currY < this.cameraY - CONFIG.HEIGHT * 3) break;
            }
        }
        
        const bg0 = this.loader.get('bg_0');
        if(bg0) {
            const bg0ScreenY = (bg0WorldY - bg0Height) - this.cameraY;
            
            if(bg0ScreenY > -bg0Height && bg0ScreenY < CONFIG.HEIGHT) {
                ctx.drawImage(bg0, 0, bg0ScreenY, CONFIG.WIDTH, bg0Height);
            }
        }
        
        for(let z = 1; z < ZONES.length; z++) {
            const splitPoint = ZONES[z].start * 10;
            const splitY = bg0WorldY - splitPoint;
            const transScreenY = (splitY - transHeight) - this.cameraY;
            
            if(transScreenY > -transHeight && transScreenY < CONFIG.HEIGHT) {
                const transImg = this.loader.get(`bg_${z}to${z + 1}`);
                if(transImg) {
                    ctx.drawImage(transImg, 0, transScreenY, CONFIG.WIDTH, transHeight);
                }
            }
        }
    }

    drawPlayer() {
        const ctx = this.ctx;
        const p = this.player;
        const screenY = p.y - this.cameraY;

        ctx.save();
        ctx.translate(p.x, screenY);
        
        if(!p.onHold) {
            ctx.rotate(p.rotation * Math.PI / 180);
        }

        let playerImg = null;
        if(p.onHold) {
            playerImg = p.facingLeft ? this.loader.get('player_left') : this.loader.get('player_right');
        } else {
            playerImg = p.facingLeft ? this.loader.get('player_left_jump') : this.loader.get('player_right_jump');
        }

        if(playerImg) {
            ctx.drawImage(playerImg, -25, -25, 50, 50);
        } else {
            ctx.fillStyle = '#fff';
            ctx.fillRect(-25, -25, 50, 50);
        }

        if(p.onHold) {
            const arrowImg = this.loader.get('arrow');
            ctx.rotate(p.arrowAngle * Math.PI / 180);
            
            if(arrowImg) {
                ctx.drawImage(arrowImg, -10, -70, 20, 40);
            } else {
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.moveTo(-5, -40);
                ctx.lineTo(0, -60);
                ctx.lineTo(5, -40);
                ctx.fill();
            }
        }

        ctx.restore();
    }

    getHoldColor(type) {
        switch(type) {
            case 'breaking': return '#f44';
            case 'ice': return '#9df';
            case 'lava': return '#f80';
            case 'magic': return '#a4f';
            case 'trap': return '#444';
            default: return '#853';
        }
    }

    loop() {
        if(this.state !== 'PLAYING') return;
        
        // FPS ê³„ì‚°
        const now = Date.now();
        const delta = now - this.lastFrameTime;
        this.fps = Math.round(1000 / delta);
        this.lastFrameTime = now;
        
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
    
    // ===== ê°œë°œì ëª¨ë“œ í•¨ìˆ˜ë“¤ =====
    
    updateConfig(key, value) {
        CONFIG[key] = parseFloat(value);
        const display = document.getElementById(`val-${key}`);
        if(display) {
            display.innerText = value;
        }
    }
    
    toggleDevPanel() {
        this.devPanelMinimized = !this.devPanelMinimized;
        const panel = document.getElementById('dev-panel');
        const btn = document.querySelector('#dev-panel .toggle-btn');
        
        if(this.devPanelMinimized) {
            panel.classList.add('minimized');
            if(btn) btn.innerText = 'â—€';
        } else {
            panel.classList.remove('minimized');
            if(btn) btn.innerText = 'â–¶';
        }
    }
    
    devTeleport(distance) {
        if(this.state !== 'PLAYING') {
            alert('ê²Œì„ ì¤‘ì—ë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.');
            return;
        }
        
        const targetY = CONFIG.HEIGHT - 120 - (distance * 10);
        this.player.y = targetY;
        this.cameraY = targetY - CONFIG.HEIGHT * 0.6;
        this.distance = distance;
        
        // ìƒˆë¡œìš´ í™€ë“œ ìƒì„±
        this.holds = [];
        this.holds.push({
            x: this.player.x,
            y: this.player.y,
            type: 'normal',
            active: true,
            timer: 0,
            originX: this.player.x,
            originY: this.player.y
        });
        this.player.onHold = this.holds[0];
        this.player.vx = 0;
        this.player.vy = 0;
        
        for(let i = 0; i < 10; i++) this.spawnHold();
        
        alert(`${distance}më¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤!`);
    }
    
    devGodMode() {
        this.godMode = !this.godMode;
        alert(this.godMode ? 'ë¬´ì  ëª¨ë“œ í™œì„±í™”!' : 'ë¬´ì  ëª¨ë“œ ë¹„í™œì„±í™”');
    }
    
    devClearProgress() {
        if(confirm('ì •ë§ë¡œ ì§„í–‰ë„ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            this.user.best = 0;
            this.save();
            alert('ì§„í–‰ë„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
        }
    }
    
    devReset() {
        if(confirm('ëª¨ë“  ì„¤ì •ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë˜ëŒë¦¬ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            Object.assign(CONFIG, DEFAULT_CONFIG);
            
            // ìŠ¬ë¼ì´ë” ê°’ ì—…ë°ì´íŠ¸
            for(let key in DEFAULT_CONFIG) {
                const slider = document.querySelector(`input[oninput*="${key}"]`);
                if(slider) {
                    slider.value = DEFAULT_CONFIG[key];
                    const display = document.getElementById(`val-${key}`);
                    if(display) display.innerText = DEFAULT_CONFIG[key];
                }
            }
            
            alert('ì„¤ì •ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
        }
    }
    
    updateDevInfo() {
        document.getElementById('debug-distance').innerText = this.distance;
        document.getElementById('debug-holds').innerText = this.holds.length;
        document.getElementById('debug-obstacles').innerText = 
            this.rocks.length + this.lavas.length + this.goblins.length;
        document.getElementById('debug-fps').innerText = this.fps;
        document.getElementById('debug-camera').innerText = Math.round(this.cameraY);
        document.getElementById('debug-godmode').innerText = this.godMode ? 'ON' : 'OFF';
        document.getElementById('debug-godmode').style.color = this.godMode ? '#0f0' : '#fff';
    }
}

const game = new Game();
</script>
</body>
</html>
